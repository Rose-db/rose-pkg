package rose

import (
	"fmt"
	"strings"
	"sync"
)

type dbReadResult struct {
	Idx uint64
	Id string
	Result string
}

/**
	A database is built with an Database.InternalDb that hold the values of
	the database in a key value map. Key is a uint while value is a []uint8 ([]byte).

	Individual indexes are stored in Database.IdLookupMap as a key value pair
	of user supplied key as a string and the index as uint.

    Database.InternalDb is growing in size as more values are stored. These size
	increaments can be called blocks.
	Blocks can hold up to 3000 indexes (value). When the reach max size, a new map
	is created with the same size.
 */
type database struct {
	InternalDb map[uint64]*[3000]*[]uint8
	// map of user supplied ids to InternalDb indexes
	// IdLookupMap::string -> idx::uint -> InternalDb[idx] -> []uint8
	IdLookupMap map[string]uint64
	idFactory *idFactory
	RWMutex *sync.RWMutex

	CurrMapIdx uint64
}

func newDatabase() *database {
	d := &database{}

	d.InternalDb = make(map[uint64]*[3000]*[]uint8)
	d.InternalDb[0] = &[3000]*[]uint8{}
	d.RWMutex = &sync.RWMutex{}

	d.IdLookupMap = make(map[string]uint64)

	m := newIdFactory()

	d.idFactory = m
	d.CurrMapIdx = 0

	return d
}

/**
	- A RW lock is acquired
	- New uint idx is generated by idFactory
 	- idx is stored in Database.IdLookupMap
	- a check is made for the current block
		- if the block does not exist, it is created
	- the value is stored in the block with its index
*/
func (d *database) Insert(id string, v *[]uint8) (uint64, uint64) {
	var idx uint64
	var m *[3000]*[]uint8
	var computedIdx, mapIdx uint64

	d.RWMutex.Lock()

	// r/w operation
	idx = d.idFactory.Next()

	m, ok := d.InternalDb[d.CurrMapIdx]

	if !ok {
		m = &[3000]*[]uint8{}
		d.InternalDb[d.CurrMapIdx] = m
	}

	// r operation
	d.IdLookupMap[id] = idx

	computedIdx = idx + (d.CurrMapIdx * 3000)

	// create the string to be saved as a single row on fs
	*v = append(*v, byte(10))
	b := []uint8(id + " ")
	*v = append(b, *v...)

	m[idx] = v

	if idx == 2999 {
		d.CurrMapIdx++
	}

	mapIdx = d.CurrMapIdx
	
	d.RWMutex.Unlock()

	return computedIdx, mapIdx
}

func (d *database) Delete(id string) {

}

func (d *database) Read(id string) (*dbReadResult, *dbReadError) {
	var idx uint64
	var m *[3000]*[]uint8
	var mapId uint64 = 0
	var b *[]uint8

	idx, ok := d.IdLookupMap[id]

	if !ok {
		return nil, &dbReadError{
			Code:    invalidReadErrorCode,
			Message: fmt.Sprintf("Invalid read operation. ID %s not exists", id),
		}
	}

	mapId = idx / 3000
	// get the map where the id value is
	m = d.InternalDb[mapId]

	// get the value of id
	b = m[idx]

	var sb strings.Builder
	sb.Grow(len(*b))

	for _, p := range *b {
		sb.WriteByte(p)
	}

	return &dbReadResult{
		Idx:    idx,
		Id:     id,
		Result: sb.String(),
	}, nil
}
