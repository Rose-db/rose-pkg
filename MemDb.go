package rose

import (
	"fmt"
	"strings"
	"sync"
)

type dbReadResult struct {
	Idx uint64
	Id string
	Result string
}

type dbInsertResult struct {
	ComputedIdx uint64
}

type dbDeleteResult struct {
	Idx uint64
}

/**
	A database is built with an Database.InternalDb that hold the values of
	the database in a key value map. Key is a uint while value is a []uint8 ([]byte).

	Individual indexes are stored in Database.IdLookupMap as a key value pair
	of user supplied key as a string and the index as uint.

    Database.InternalDb is growing in size as more values are stored. These size
	increaments can be called blocks.
	Blocks can hold up to 3000 indexes (value). When the reach max size, a new map
	is created with the same size.
 */
type memDb struct {
	InternalDb map[uint64]*[3000]*[]uint8
	// map of user supplied ids to InternalDb indexes
	// IdLookupMap::string -> idx::uint -> InternalDb[idx] -> []uint8
	IdLookupMap map[string]uint64
	FreeIdsList []uint64
	idFactory *idFactory
	RWMutex *sync.RWMutex

	CurrMapIdx uint64
}

func newMemoryDb() *memDb {
	d := &memDb{}

	d.InternalDb = make(map[uint64]*[3000]*[]uint8)
	d.InternalDb[0] = &[3000]*[]uint8{}
	d.RWMutex = &sync.RWMutex{}
	d.FreeIdsList = []uint64{}

	d.IdLookupMap = make(map[string]uint64)

	m := newIdFactory()

	d.idFactory = m
	d.CurrMapIdx = 0

	return d
}

/**
	- A RW lock is acquired
	- New uint idx is generated by idFactory
 	- idx is stored in Database.IdLookupMap
	- a check is made for the current block
		- if the block does not exist, it is created
	- the value is stored in the block with its index
*/
func (d *memDb) Insert(id string, v *[]uint8) *dbInsertResult {
	d.RWMutex.Lock()

	var idx uint64
	var m *[3000]*[]uint8
	var computedIdx uint64


	// r/w operation, create uint64 index
	idx = d.idFactory.Next()

	// check if the current block exists or need to be created
	m, ok := d.InternalDb[d.CurrMapIdx]

	if !ok {
		// current block does not exist, created a new one
		m = &[3000]*[]uint8{}
		d.InternalDb[d.CurrMapIdx] = m
	}

	// r operation, add index to the index map
	d.IdLookupMap[id] = idx

	computedIdx = idx + (d.CurrMapIdx * 3000)

	// saving the pointer address of the data, not the actual data
	m[idx] = v

	if idx == 2999 {
		d.CurrMapIdx++
	}

	d.RWMutex.Unlock()

	return &dbInsertResult{
		ComputedIdx: computedIdx,
	}
}

func (d *memDb) Delete(id string) *AppResult {
	d.RWMutex.Lock()

	var idx, mapId uint64
	var m *[3000]*[]uint8

	idx, ok := d.IdLookupMap[id]

	if !ok {
		return &AppResult{
			Id:     0,
			Method: DeleteMethodType,
			Status: NotFoundResultStatus,
			Reason: fmt.Sprintf("Rose: Id %s does not exist", id),
			Result: "",
		}
	}

	mapId = idx / 3000
	// get the map where the id value is
	m = d.InternalDb[mapId]

	delete(d.IdLookupMap, id)
	m[idx] = nil

	d.FreeIdsList = append(d.FreeIdsList, idx)

	d.RWMutex.Unlock()

	return &AppResult{
		Id:     idx,
		Method: DeleteMethodType,
		Status: EntryDeletedStatus,
	}
}

func (d *memDb) Read(id string) *dbReadResult {
	d.RWMutex.Lock()

	var idx uint64
	var m *[3000]*[]uint8
	var mapId uint64 = 0
	var b *[]uint8

	idx, ok := d.IdLookupMap[id]

	if !ok {
		return nil
	}

	mapId = idx / 3000
	// get the map where the id value is
	m = d.InternalDb[mapId]

	// get the value of id, value is a pointer, not the actual data
	b = m[idx]

	var sb strings.Builder
	sb.Grow(len(*b))

	for _, p := range *b {
		sb.WriteByte(p)
	}

	d.RWMutex.Unlock()

	return &dbReadResult{
		Idx:    idx,
		Id:     id,
		Result: sb.String(),
	}
}
